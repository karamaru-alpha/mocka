// Code generated by mocka. DO NOT EDIT.
package testdata

import (
	"reflect"
	"testing"
)

type MockHuman struct {
	t       *testing.T
	MockSay *mHuman_Say
}

func NewMockHuman(t *testing.T) *MockHuman {
	mockSay := &mHuman_Say{
		t: t,
	}
	t.Cleanup(func() {
		if mockSay.stab != nil {
			return
		}
		for _, expect := range mockSay.expects {
			if expect.times != 0 {
				if expect.condition != nil {
					t.Fatalf("Human.Say conditional expected more %d times. expectNumber: %d", expect.times, expect.number)
				}
				t.Fatalf("Human.Say expected more %d times. args: %+v, expectNumber: %d", expect.times, expect.args, expect.number)
			}
		}
	})
	return &MockHuman{
		t:       t,
		MockSay: mockSay,
	}
}

func (m *MockHuman) Say(name string) (result0 string) {
	if m.MockSay.stab != nil {
		return m.MockSay.stab(name)
	}
	for _, expect := range m.MockSay.expects {
		if expect.times == 0 {
			continue
		}
		if expect.condition != nil {
			if !expect.condition(name) {
				continue
			}
		} else if !reflect.DeepEqual(expect.args.name, name) {
			continue
		}
		expect.times--
		return expect.results.result0
	}
	m.t.Fatalf("Human.Say unexpected call. name: %+v", name)
	panic("not reachable")
}

type mHuman_SayExpect struct {
	number int
	args   struct {
		name string
	}
	condition func(name string) bool
	times     int
	results   struct {
		result0 string
	}
}

type mHuman_Say struct {
	t       *testing.T
	expects []*mHuman_SayExpect
	stab    func(name string) string
}

func (m *mHuman_Say) Expect(name string) *mHuman_SayExpected {
	if m.stab != nil {
		m.t.Fatalf("Human.Say cannot expect after stabilize")
	}
	return &mHuman_SayExpected{
		m: m,
		expect: &mHuman_SayExpect{
			args: struct {
				name string
			}{
				name: name,
			},
		},
	}
}

func (m *mHuman_Say) ConditionalExpect(condition func(name string) bool) *mHuman_SayExpected {
	if m.stab != nil {
		m.t.Fatalf("Human.Say cannot expect after stabilize")
	}
	return &mHuman_SayExpected{
		m: m,
		expect: &mHuman_SayExpect{
			condition: condition,
		},
	}
}

func (m *mHuman_Say) Stabilize(stab func(name string) string) {
	if len(m.expects) > 0 {
		m.t.Fatalf("Human.Say cannot stabilize after expect")
	}
	m.stab = stab
}

type mHuman_SayExpected struct {
	m      *mHuman_Say
	expect *mHuman_SayExpect
}

func (m *mHuman_SayExpected) Times(n int) *mHuman_SayTimesExpected {
	m.expect.times = n
	return &mHuman_SayTimesExpected{
		m:      m.m,
		expect: m.expect,
	}
}

type mHuman_SayTimesExpected struct {
	m      *mHuman_Say
	expect *mHuman_SayExpect
}

func (m *mHuman_SayTimesExpected) Return(result0 string) {
	m.expect.results = struct {
		result0 string
	}{
		result0: result0,
	}
	m.expect.number = len(m.m.expects) + 1
	m.m.expects = append(m.m.expects, m.expect)
}
