// Code generated by mocka. DO NOT EDIT.
package {{ .Package }}

import (
    "testing"
    "reflect"
    {{- range .ImportPaths }}
    "{{ . }}"
    {{- end }}
)

{{ range .Interfaces -}}
{{ $interfaceName := .Name -}}
type Mock{{ $interfaceName }} struct {
    t *testing.T
    {{- range .Methods }}
    Mock{{ .Name }} *m{{ $interfaceName }}_{{ .Name }}
    {{- end }}
}

func NewMock{{ $interfaceName }}(t *testing.T) *Mock{{ $interfaceName }} {
    {{- range .Methods }}
    mock{{ .Name }} := &m{{ $interfaceName }}_{{ .Name }}{
        t: t,
    }
    t.Cleanup(func() {
        if mock{{ .Name }}.stab != nil {
            return
        }
        for _, expect := range mock{{ .Name }}.expects {
            if expect.times != 0 {
                if expect.condition != nil {
                    t.Fatalf("{{ $interfaceName }}.{{ .Name }} conditional expected more %d times. expectNumber: %d", expect.times, expect.number)
                }
                {{- if .Args }}
                t.Fatalf("{{ $interfaceName }}.{{ .Name }} expected more %d times. args: %+v, expectNumber: %d", expect.times, expect.args, expect.number)
                {{- else }}
                t.Fatalf("{{ $interfaceName }}.{{ .Name }} expected more %d times. expectNumber %d", expect.times, expect.number)
                {{- end }}
            }
        }
    })
    {{- end }}
    return &Mock{{ $interfaceName }}{
        t: t,
        {{- range .Methods }}
        Mock{{ .Name }}: mock{{ .Name }},
        {{- end }}
    }
}

{{ range .Methods -}}
{{- $argLen := len .Args -}}
{{- $resultLen := len .Results -}}

func (m *Mock{{ $interfaceName }}) {{ .Name }}({{ range $i, $v := .Args }}{{ $v.Name }} {{ $v.Type }}{{ if lt (add $i) $argLen }}, {{ end }}{{ end }}) {{- if .Results }} ({{ range $i, $v := .Results }}{{ $v.Name }} {{ $v.Type }}{{ if lt (add $i) $resultLen }}, {{ end }}{{ end }}) {{- end }} {
    if m.Mock{{ .Name }}.stab != nil {
        {{ if .Results -}} return {{ end -}} m.Mock{{ .Name }}.stab({{ range $i, $v := .Args }}{{ $v.Name }}{{ if lt (add $i) $argLen }}, {{ end }}{{ end }})
        {{ if not .Results -}} return {{- end -}}
    }
    for _, expect := range m.Mock{{ .Name }}.expects {
        if expect.times == 0 {
            continue
        }
        if expect.condition != nil {
            if !expect.condition({{ range $i, $v := .Args }}{{ $v.Name }}{{ if lt (add $i) $argLen }}, {{ end }}{{ end }}) {
                continue
            }
        } {{- if .Args }} else if {{ range $i, $v := .Args }}!reflect.DeepEqual(expect.args.{{ $v.Name }}, {{ $v.Name }}){{ if lt (add $i) $argLen }} || {{ end }}{{ end }} {
            continue
        }{{- end }}
        expect.times--
        return {{ range $i, $v := .Results }}expect.results.{{ $v.Name }}{{ if lt (add $i) $resultLen }}, {{ end }}{{ end }}
    }
    m.t.Fatalf("{{ $interfaceName }}.{{ .Name }} unexpected call{{ if .Args }}. {{ end }}{{ range $i, $v := .Args }}{{ $v.Name }}: %+v{{ if lt (add $i) $argLen }}, {{ end }}{{ end }}", {{ range $i, $v := .Args }}{{ $v.Name }}{{ if lt (add $i) $argLen }}, {{ end }}{{ end }})
    panic("not reachable")
}

type m{{ $interfaceName }}_{{ .Name }}Expect struct {
	number int
	{{- if .Args }}
	args struct{
		{{- range .Args }}
		{{ .Name }} {{ .Type }}
		{{- end }}
	}
	{{- end }}
	condition func({{ range $i, $v := .Args }}{{ $v.Name }} {{ $v.Type }}{{ if lt (add $i) $argLen }}, {{ end }}{{ end }}) bool
	times int
	{{- if .Results }}
	results struct{
		{{- range .Results }}
		{{ .Name }} {{ .Type }}
		{{- end }}
	}
	{{- end }}
}

type m{{ $interfaceName }}_{{ .Name }} struct {
    t *testing.T
    expects []*m{{ $interfaceName }}_{{ .Name }}Expect
    stab func({{ range $i, $v := .Args }}{{ $v.Name }} {{ $v.Type }}{{ if lt (add $i) $argLen }}, {{ end }}{{ end }}) {{- if .Results }} ({{ range $i, $v := .Results }}{{ $v.Type }}{{ if lt (add $i) $resultLen }}, {{ end }}{{ end }}) {{- end }}
}

func (m *m{{ $interfaceName }}_{{ .Name }}) Expect({{ range $i, $v := .Args }}{{ $v.Name }} {{ $v.Type }}{{ if lt (add $i) $argLen }}, {{ end }}{{ end }}) *m{{ $interfaceName }}_{{ .Name }}Expected {
    if m.stab != nil {
        m.t.Fatalf("{{ $interfaceName }}.{{ .Name }} cannot expect after stabilize")
    }
    return &m{{ $interfaceName }}_{{ .Name }}Expected{
        m: m,
        expect: &m{{ $interfaceName }}_{{ .Name }}Expect{
        	{{- if .Args }}
        	args: struct{
				{{- range .Args }}
				{{ .Name }} {{ .Type }}
				{{- end }}
			}{
				{{- range .Args }}
				{{ .Name }}: {{ .Name }},
				{{- end }}
			},
        	{{- end }}
        },
    }
}

func (m *m{{ $interfaceName }}_{{ .Name }}) ConditionalExpect(condition func({{ range $i, $v := .Args }}{{ $v.Name }} {{ $v.Type }}{{ if lt (add $i) $argLen }}, {{ end }}{{ end }}) bool) *m{{ $interfaceName }}_{{ .Name }}Expected {
    if m.stab != nil {
        m.t.Fatalf("{{ $interfaceName }}.{{ .Name }} cannot expect after stabilize")
    }
    return &m{{ $interfaceName }}_{{ .Name }}Expected{
        m: m,
        expect: &m{{ $interfaceName }}_{{ .Name }}Expect{
        	condition: condition,
        },
    }
}

func (m *m{{ $interfaceName }}_{{ .Name }}) Stabilize(stab func({{ range $i, $v := .Args }}{{ $v.Name }} {{ $v.Type }}{{ if lt (add $i) $argLen }}, {{ end }}{{ end }}) ({{ range $i, $v := .Results }}{{ $v.Type }}{{ if lt (add $i) $resultLen }}, {{ end }}{{ end }})) {
    if len(m.expects) > 0 {
        m.t.Fatalf("{{ $interfaceName }}.{{ .Name }} cannot stabilize after expect")
    }
    m.stab = stab
}

type m{{ $interfaceName }}_{{ .Name }}Expected struct {
    m *m{{ $interfaceName }}_{{ .Name }}
	expect *m{{ $interfaceName }}_{{ .Name }}Expect
}

func (m *m{{ $interfaceName }}_{{ .Name }}Expected) Times(n int) *m{{ $interfaceName }}_{{ .Name }}TimesExpected {
	m.expect.times = n
    return &m{{ $interfaceName }}_{{ .Name }}TimesExpected{
        m: m.m,
        expect: m.expect,
    }
}

type m{{ $interfaceName }}_{{ .Name }}TimesExpected struct {
    m *m{{ $interfaceName }}_{{ .Name }}
    expect *m{{ $interfaceName }}_{{ .Name }}Expect
}

func (m *m{{ $interfaceName }}_{{ .Name }}TimesExpected) Return({{ range $i, $v := .Results }}{{ $v.Name }} {{ $v.Type }}{{ if lt (add $i) $resultLen }}, {{ end }}{{ end }}) {
	{{- if .Results }}
	m.expect.results = struct{
	   {{- range .Results }}
	   {{ .Name }} {{ .Type }}
	   {{- end }}
    }{
	   {{- range .Results }}
	   {{ .Name }}: {{ .Name }},
	   {{- end }}
    }
	{{- end }}
	m.expect.number = len(m.m.expects) + 1
    m.m.expects = append(m.m.expects, m.expect)
}

{{ end }}
{{ end -}}
